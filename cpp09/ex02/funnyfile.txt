# **************************************************************************** #
#                                                                              #
#                                                         :::      ::::::::    #
#    funnyfile.txt                                      :+:      :+:    :+:    #
#                                                     +:+ +:+         +:+      #
#    By: dcastagn <dcastagn@student.42.fr>          +#+  +:+       +#+         #
#                                                 +#+#+#+#+#+   +#+            #
#    Created: 2023/10/24 20:40:44 by zmoumen           #+#    #+#              #
#    Updated: 2023/11/27 15:24:57 by dcastagn         ###   ########.fr        #
#                                                                              #
# **************************************************************************** #

#pragma once
#include <algorithm>
#include <iostream>
#include <vector>
#include <list>

/// @brief  global variable to count the number of compares
/// @brief  altered in pair sorting and binary search insertion functions
/// @brief  ford_johnson has a worst case of 66 compares
int gcomparescnt = 0;


/// @brief jacobsthal sequence for insertion order
/// @brief the sequence is used to pick from pent element to be inserted into mainchain
size_t jacobsthal_diff[] = {
        2u, 2u, 6u, 10u, 22u, 42u, 86u, 170u, 342u, 682u, 1366u,
        2730u, 5462u, 10922u, 21846u, 43690u, 87382u, 174762u, 349526u, 699050u,
        1398102u, 2796202u, 5592406u, 11184810u, 22369622u, 44739242u, 89478486u,
        178956970u, 357913942u, 715827882u, 1431655766u, 2863311530u, 5726623062u,
        11453246122u, 22906492246u, 45812984490u, 91625968982u, 183251937962u,
        366503875926u, 733007751850u, 1466015503702u, 2932031007402u, 5864062014806u,
        11728124029610u, 23456248059222u, 46912496118442u, 93824992236886u, 187649984473770u,
        375299968947542u, 750599937895082u, 1501199875790165u, 3002399751580331u,
        6004799503160661u, 12009599006321322u, 24019198012642644u, 48038396025285288u,
        96076792050570576u, 192153584101141152u, 384307168202282304u, 768614336404564608u,
        1537228672809129216u, 3074457345618258432u, 6148914691236516864u
};

template <typename IT>
IT safe_advance(IT it, typename IT::difference_type n, IT end)
{
	if (std::distance(it, end) < n)
		return end;
	std::advance(it, n);
	return it;
}

template <typename IT>
void swaprange(IT ls, IT le, IT rs, IT re)
{
	while (ls != le && rs != re)
		std::swap(*ls++, *rs++);
	std::swap(*ls, *rs);
}

/// @brief expand the container by n elements
template <typename T>
void aux__fj_container_expand(std::vector<T>& cont, size_t n){cont.reserve(cont.size() + n);}
template <typename T>
void aux__fj_container_expand(std::list<T>&, size_t) {} // do nothing, needed for template

/// @brief binary search for a pair unit in container
/// @param begin iterator to begin range
/// @param end iterator to end range
/// @param val the value to be searched for
/// @param unitsize the size of the pair unit to be searched for
/// @return an iterator to where to insert val
template <typename T, typename V>
T	aux__fj_pair_binary_search(T begin, T end, V val, typename T::difference_type unitsize)
{
	typename T::difference_type count, unitend;
	unitend = unitsize - 1;
	while (begin != end)
	{
		count = std::distance(begin, end) / unitsize;
		T midit = safe_advance(begin, (count / 2) * unitsize, end);
		T miditend = safe_advance(midit, unitend, end);
		gcomparescnt++;
		if (*miditend < val)
			begin = safe_advance(miditend, 1, end);
		else
			end = midit;
	}
	return end;
}

/// @brief aux function to sort pairs of elements in a container
/// @brief it sorts the each pair internally.
/// @brief example: [3,5,4,7,1,8,2,6]->[1,8,2,6][3,5,4,7](pairsize is 8)
/// @brief a unit is half the pair, unit value is the last elemnt of the unit
template <typename IT>
IT	aux__fj_pairsort(IT begin, IT end, typename IT::difference_type pairsize)
{
	typename IT::difference_type unitsize, unitend;
	unitsize = pairsize / 2;
	unitend = unitsize - 1;
	for (IT ls = begin; ls != end ; ls = safe_advance(ls, pairsize, end))
	{
		IT le = safe_advance(ls, unitend, end);
		IT rs = safe_advance(le, 1, end);
		if (rs == end) return ls;
		IT re = safe_advance(rs, unitend, end);
		gcomparescnt++;
		if (*le > *re)
			swaprange(ls, le, rs, re);
	}
	return (end);
}

/// @brief Aux function to generate the mainchain and the pent from container.
/// @brief It inserts the fist pairsize elements into the mainchain,
/// @brief Then insert each odd/even pairunit respectively into the pent/mainchain.
/// @param cont the container to be sorted
/// @param cend the end position to be sorted
/// @return an iterator to the first element of each unit in the mainchain.
/// @return each element in the returned vector is index-paired with a unit in pend.
template <typename T, typename IT, typename DIFF>
std::vector<IT> aux__fj_gen_mainchain_n_pent(T& cont, IT cend, DIFF pairsize,
	T& mainchain, T& pent)
{
	DIFF unitsize;
	std::vector<IT> mainchain_its;

	unitsize = pairsize / 2;
	mainchain.insert(mainchain.begin(),
			cont.begin(), safe_advance(cont.begin(), pairsize, cend));
	for (IT ls = safe_advance(cont.begin(), pairsize, cend);
		ls != cend; ls = safe_advance(ls, pairsize, cend))
	{
		pent.insert(pent.end(), ls, safe_advance(ls, unitsize, cend));
		IT rs = safe_advance(ls, unitsize, cend);
		mainchain.insert(mainchain.end(), rs, safe_advance(rs, unitsize, cend));
	}
	for (IT ms = safe_advance(mainchain.begin(), pairsize, mainchain.end());
		ms != mainchain.end(); ms = safe_advance(ms, unitsize, mainchain.end()))
	{
		mainchain_its.push_back(ms);
	}
	if (pent.size() / unitsize != mainchain_its.size())
		mainchain_its.push_back(mainchain.end());
	return mainchain_its;
}

/// @brief aux function to shift iterators if the insert_pos is before them
/// @param mainchain_its the iterators of the mainchain high elements (index-paired to pends)
/// @param insert_pos the position in the mainchain where the pent element was inserted
/// @param unitsize the size of the pair unit inserted
/// @param mend the end of the mainchain
template <typename MITC, typename IT, typename DIFF>
void aux__fj__move_mainchain_its(MITC& mainchain_its, IT insert_pos, DIFF unitsize, IT mend)
{
	for (typename MITC::iterator it = mainchain_its.begin(); it != mainchain_its.end(); it++)
		if (std::distance(insert_pos, *it) >= 0) *it = safe_advance(*it, unitsize, mend);
}
/// @brief aux function to insert a pent element into the mainchain and remove it
/// @param mainchain the mainchain
/// @param pent the pent
/// @param unitsize the size of the pairs to be sorted (2 for the first call)
/// @param pick_pos the position of the element from the pent to be inserted
/// @param mainchain_its the iterators of the mainchain high elements (index-paired to pends)
/// @param moveits set to true if chosen container::iterator shift if new elements are inserted
template <typename C, typename DIFF, typename MITC>
void aux__fj__insertion(C& mainchain, C& pent,
	DIFF unitsize, size_t pick_pos, MITC& mainchain_its, bool moveits)
{
	DIFF unitend = unitsize - 1;
	
	typename C::iterator ps = safe_advance(pent.begin(), pick_pos * unitsize, pent.end());
	typename C::iterator pe = safe_advance(ps, unitend, pent.end());

	typename MITC::iterator mit = mainchain_its.begin() + pick_pos;
	typename C::iterator insert_pos = aux__fj_pair_binary_search(mainchain.begin(), *mit, *pe, unitsize);
	mainchain.insert(insert_pos, ps, safe_advance(ps, unitsize, pent.end()));

	if (moveits)aux__fj__move_mainchain_its(mainchain_its, insert_pos, unitsize, mainchain.end());
	mainchain_its.erase(mit);
	pent.erase(ps, safe_advance(ps, unitsize, pent.end()));
}

/// @brief sorts a container using the ford johnson algorithm
/// @param cend the end of the container to be sorted
/// @param pairsize the size of the pairs to be sorted (2 for the first call)
/// @param moveits set to true if chosen container::iterator shift if new elements are inserted
template <typename T>
void ford_johnson(T& cont, typename T::iterator cend,
	typename T::iterator::difference_type pairsize, bool moveits)
{
	typedef typename T::iterator iter_t;
	typename T::iterator::difference_type unitsize = pairsize / 2;
 	T mainchain;
	T pent;
	std::vector<iter_t> mainchain_its;

	// sort pairs individually
	iter_t rest = aux__fj_pairsort(cont.begin(), cend, pairsize);
	
	// double the pairsize and sort the pairs sort recursively
	if (pairsize < std::distance(cont.begin(), rest))
		ford_johnson(cont, rest, pairsize * 2,  moveits);

	aux__fj_container_expand(mainchain, std::distance(cont.begin(), rest)); // avoid reallocation and iterators loss
	mainchain_its = aux__fj_gen_mainchain_n_pent(cont, cend, pairsize, mainchain, pent);

	// insert by jacobsthal sequence,ex: j= 2 then insert index 2, 1, 0
	for (size_t j , k = 0; (j = jacobsthal_diff[k]) <= (pent.size() / unitsize) ; k++)
		while (j > 0) aux__fj__insertion(mainchain, pent, unitsize, --j,  mainchain_its, moveits);

	// insert the rest
	while (pent.size()) aux__fj__insertion(mainchain, pent, unitsize, 0, mainchain_its, moveits);
	cont.erase(cont.begin(), cend);
	cont.insert(cont.begin(), mainchain.begin(), mainchain.end());
}

/// @brief convert the arguments to integers and insert them into the container
template <typename T>
void	populate(char** av, T& cont)
{
	std::insert_iterator<T> it(cont, cont.begin());
	for (char* s = *av++; s; s = *av++)
		*it++ = std::strtod(s, NULL);
}

/// @brief  print the container elements
/// @param prefix prefix to be printed before the container
/// @param presult print if container is sorted or not
template <typename T>
void print_containers(std::string prefix,T& cont, bool presult)
{
	std::cout << prefix << ": ";
	bool sorted = true;
	for (typename T::iterator it = cont.begin(); it != cont.end(); it++)
	{
		std::cout << *it << " ";
		typename T::iterator next = it;
		next++;
		if (next != cont.end() && *it > *next)
			sorted = false;
	}
	if (presult || !sorted) std::cout << " is " << (sorted ? "" : "<!>NOT<!> ") << "sorted";
	if (presult) std::cout << " with " << gcomparescnt << " compares";
	std::cout << std::endl;
}

template<typename T>
void print_chrono(long duration, T&cont, std::string cname)
{
	std::cout << "time to process a range of " << cont.size() << " elements with "
			  << cname << ": " << duration << " us" << std::endl;
}

long getusec_(); //defined in main.cpp

/// @brief test the container with the ford johnson algorithm
/// @param moveits set to true if chosen container::iterator shift if new elements are inserted
template<typename T>
void test_container(char **av, std::string cont_name, bool presult, bool moveits)
{
	T cont;
	long start = 0;
	long stop = 0;

	start = getusec_();
	populate(av, cont);
	gcomparescnt = 0;
	ford_johnson(cont, cont.end(), 2, moveits);
	stop = getusec_();
	if (presult) print_containers("after", cont, false);
	print_chrono(stop - start, cont, cont_name);
}